The Project: to write an assembler for a specific assembly language defined here specifically for this project.
## Hardware

- "The computer in the project" 
	- consists of: 
		- CPU (Central Processing Unit)
			- [[#Registers]]
		- Memory (stack). Some of the memory serves as a stack (RAM).
			- size: 4096 cells. (words)
			- addresses ranging from 0 to 4095 (decimal).
			- cell (word) size: 14 bits, 
			- The bits in each word are numbered similarly to the register.



- This computer operates only with positive and negative integers; there is no support for floating-point numbers. 
- Arithmetic is performed using the two's complement method.
- There is also support for characters, represented in ASCII code

# CPU

## Registers

- 8 general registers named `r0, r1, r2, r3, r4, r5, r6, r7`
- Register: 14 bits. 
	- The least significant bit is denoted as bit 0 and the most significant bit as bit 13. 
	- The register names are always written with a lowercase `r`
- A register named **Program Status Word** (PSW), which contains flags characterizing the processor's state at any given moment.

## Machine Instructions

### Machine Instruction Structure

- Each machine instruction (הוראת מכונה) is encoded into a sequence of consecutive **memory words**, 
- range: min: one word, max: 5 words, depending on the addressing modes used (see later #todo )
- In the output file containing the machine code generated by the assembler, each word is encoded in the Base 4 Encoded as defined below (see explanations and examples later):

| Base 4 - Regular | Base 4 - Encoded |
| -------------- | -------------- |
| `0`            | `*`            |
| `1`            | `#`            |
| `2`            | `%`            |
| `3`            | `!`            |

#### The first word

The structure of the first word is always the same. The structure of the first word in an instruction is as follows: (`xxxx.xxxx.xx.xx.xx`)

| Bits | `10 11 12 13` | `6 7 8 9` | `4 5` | `2 3` | `0 1` |
| ---- | ---- | ---- | ---- | ---- | ---- |
| **Field** | Not used | `opcode` | Operand Ad. (Source) | Operand Ad. (Destination) | `A, R, E` |


- Bits `0-1` (the '`A.R.E`' field):
	- In the first word of an instruction, these bits are always set to zero (`00`).

- Bits `2-3`: Encode the number of the addressing mode for the **destination operand**. If there is no destination operand in the instruction, the value of these bits is `0`.
- Bits `4-5`: Encode the number of the addressing mode for the **source operand**. If there is no source operand in the instruction, the value of these bits is `0`.
- Bits `6-9`: In the first word of the instruction, these bits represent the **operation code** (opcode). Each opcode is symbolically represented in assembly language by an **operation name**.

| opcode | Operation Name |
| ------ | -------------- |
| 0      | mov            |
| 1      | cmp            |
| 2      | add            |
| 3      | sub            |
| 4      | not            |
| 5      | clr            |
| 6      | lea            |
| 7      | inc            |
| 8      | dec            |
| 9      | jmp            |
| 10     | bne            |
| 11     | red            |
| 12     | prn            |
| 13     | jsr            |
| 14     | rts            |
| 15     | hlt            |

- Bits `10-13`: not used and their value is `0`.

### Machine instructions specification

- **Program Counter** (PC)
	- This is an **internal register** of the processor (not a **general register**), which at any given moment contains the memory address where the current instruction being executed is located (always referring to the address of the first word of the instruction).

The machine instructions are divided into three groups, according to the number of operands required for the operation.

- The **first set** of instructions
	- number of operands: `2`
	- set: `mov, cmp, add, sub, lea`
- The **second set** of instructions:
	- number of operands: `1`
	- set: `not, clr, inc, dec, jmp, bne, red, prn, jsr`
	- The Instruction Encoding: is the same as the target operand in a command with two operands. 
	- In this case, the field of the source operand (`4-5` bits ) in the first word in the coding of the instruction it is meaningless, and therefore will contain `00`.
- The **third set** of instructions:
	- number of operands: `0`
	- set: `rts, hlt`
	- The Instruction Encoding: only one word
	- the field of the source & destination operands in the first word are not used, thus there are zero (???)

#### 1st set 

- The `mov` (Move) instruction is used to transfer data between registers, memory locations, and immediate values.
	- Syntax: `mov destination, source`
	- Example: `mov A, r1` copies the value from register `A` to register `r1`.
- The `cmp` (Compare) instruction performs a comparison between its two operands. the content of the destination operand (the second) is subtracted from the content of the source operand (the first), without saving the result of the subtraction. The subtraction operation updates a flag called the `Z` variable in the status register (PSW).
	- Syntax: `cmp operand1, operand2`
	- Example: `cmp A, r1`, If the contents of the variable `A` equal to the contents of register `r1` then the zero flag, `Z`, in the status register (PSW) will be turn on, otherwise the flag will be reset.
- The `add` (Addition) instruction performs integer addition between two operands and stores the result in the destination operand.
	- Syntax: `add destination, source`
	- Example: `add A, r0` adds the value in register `A` to the value in register `r0`.
- The `sub` (Subtraction) instruction performs integer subtraction between two operands and stores the result in the destination operand.
    - Syntax: `sub destination, source`
    - Example: `sub #3, r1`, register `r1` receives the result of subtracting the value `3` from the current contents of register `r1`.
- The `lea` (Load Effective Address) instruction places the address in memory represented by the label in the first operand (the source), to the destination operand (the second operand)
    - It does not access memory; it only computes the address.
    - Syntax: `lea .....???` 
    - Example: `lea HELLO, r1` The address represented by the label `HELLO` is placed in the `r1` register

#### 2nd set 

- `not` 
	- `not r2` will do `r2 ← not r2`
- `clr` 
	- `clr r2` will do `r2 ← 0`
- `inc` 
	- `inc r2` will do `r2 ← r2 + 1`
- `dec` 
	- `dec C` will do `C ← C - 1`
- `jmp` (Jump) - Unconditional jump to the instruction specified by the label.
	- Syntax `jmp LABEL`
	- Example: `jmp LINE` will do `PC ← LINE`
- `bne` (**B**ranch if **N**ot **E**qual to Zero) - Conditional branch. The program pointer (PC) will receive the value of the destination operand,  if the value of the flag `Z` in the status register (PSW) is `0`. (Reminder: The Z flag is set in the "cmp" command.)
	- Syntax `bne ....??`
	- Example `bne LINE`, if the value of the flag `Z` in the status register (PSW) is `0`, then `PC ← LINE`
- `red` (Read) - Reads a character from `stdin` (The Standard Input), and stores its ASCII code in the specified register
   - Syntax `red REGISTER`
   - Example: `red r1`
- `prn` (Print) - Prints the ASCII character represented by the operand to `stdout` (The Standard Output)
	- Syntax `prn OPERAND`
	- Example: `prn r1`
- `jsr` (Jump to Subroutine) - Calls a subroutine. The current program counter (PC) is pushed onto the stack, and the operand is inserted into PC
   - Syntax: `jsr LABEL`
   - Example: `jsr FUNC` will do `push(PC)` and then `PC ← FUNC`

#### 3rd set 

- `rts` (**R**e**T**urn from **S**ubroutine) 
	- Back from routine. The value at the top of the computer's stack is taken from the stack, and inserted into the program pointer (PC, Program Counter).
	- `rts` will do `PC ← pop()`
- `hlt` (Halt) Stopping the program

### A.R.E. field 

- At each word in the machine code of an instruction (not of data), the assembler inserts information for the linking and loading process. This is the A,R,E field. The information will be used to make corrections to the code every time it is loaded into memory for execution. The assembler builds from scratch code that is intended to be loaded starting from the start address. The fixes will make it possible to load the code in a different place each time, without having to repeat the assembly process.
- The A.R.E field is added to each word in the instruction encoding

| Encoding Type | Bits | Meaning | Example |
| ---- | ---- | ---- | ---- |
| Absolute (A) | `00` | indicate that the content of the word does not depend on the place in memory where the machine code of the program will actually be loaded during its execution. (thus, requiring no changes in the linkage and loading stages) | a word containing an immediate operand |
| Relocatable (R) | `10` | indicate that the content of the word depends on the place in memory where the machine code of the program will actually be loaded when it is executed (thus, requiring changes linkage & loading) | a word containing the address of a label defined in the source file |
| External (E) | `01` | indicates that the content of the word depends on the value of an external symbol (thus, requiring changes linkage & loading) | a word containing the address of an external label, i.e. a label that is not defined in the source file |
### Addressing Modes

In our language, there are four addressing modes, marked with the numbers `0`, `1`, `2`, and `3`.

Using addressing modes requires encoding additional data words in the machine code of the instruction.

If a command has one operand, there will be one additional data word. 

If a command has two operands, there may be two additional data words, or one shared data word for both operands, depending on the addressing modes used (see specifications below).

When encoding the instruction, if there are two additional data words, the first data word refers to the source operand, and the second refers to the destination operand.

- In each additional data word, bits `0-1` represent the `A, R, E` field.

Description of the addressing modes in our machine:

| Value | Addressing Mode | Additional Word(s) |  |
| ---- | ---- | ---- | ---- |
| `0` | Immediate Addressing | 1 | מיעון מיידי |
| `1` | Direct Addressing | 2 | מיעון ישיר |
| `2` | Index Addressing | 1 | מיעון אינדקס קבוע |
| `3` | Register Addressing | 1 | מיעון רגיסטר ישיר |

#### (0) Immediate Addressing (מיעון מיידי) 

- Additional information word of the instruction contains the operand itself, which is an integer using the 2's complement method, represented with a width of 12 bits, to which a pair of bits of the field `A,R,E` are added (the value of this field is always `00` for immediate addressing).
- The operand starts with the character `#` and after it and next to it appears a whole number in decimal base. There is also a possibility that the constant name defined in the program by `.define` will appear instead of the number (see details below [[#Constant Definition Statement (משפט הגדרת קבוע)]]).
- Examples:
	- `mov #-1,r2` in this example the first operand of the command is given in an immediate addressing mode. The instruction writes the value `1` to register `r2` 
	- given the definition of the constant: `.define size = 8` so in the instruction: `mov #size, r1` the first operand is immediate, when the number `8` is represented by the constant name size. The instruction writes the value `8` to register `r1`

#### (1) Direct Addressing (מיעון ישיר) 


- The additional information word of the instruction contains the address of a word in memory. This word in memory is the operand. The address is represented as an unsigned number with a width of `12` bits, to which a pair of bits of the `A,R,E` field is added (the value of this field is either `01` or `10`, depending on the type of address - *external* or *internal*).
- The operand is a label that has already been declared or will be declared later in the file. The statement is made by writing a label at the beginning of the landing `.data` or `.string` or at the beginning of an instruction of the program, or using an operand of the `.extern`
- Example: given `x: .data 23`, then the instruction `dec x` decreases by 1 the content of the word at address `x` in memory (the variable `x`).

#### (2) Index Addresing (מיעון אינדקס קבוע) 

- This addressing mode is used to access an array member by index. The array is in memory. Each member of the array is a size word
	- Additional information word(s) in the instruction encoding: 
		- The 1st additional word contains the starting address of the array. 
		- The 2nd additional word contains the index of the element in the array to be accessed. 
	- The values in the two additional data words are represented with a width of `12` bits, to which a pair of bits from the `A,R,E` field is added (the value of this field in the first data word is as in (מיעון ישיר), and in the second data word as in (מיעון מידי).

- The operand consists of a label indicating the starting address of the array, followed by the index in the array to be accessed in square brackets. The index can be given by a numerical constant defined with `.define`. The indexes in the array start from 0.
- Examples:
	- Given the definition `x: .data 23,25,19,30`, then the instruction `mov x[2],r2` will copy the number `19` found in index `2` in the array `x` to the register `.r2`
	- Given the definition of the array `x` above, as well as the constant definition `.define k=1` then the instruction: `mov r2,x[k]` will copy the content of the register `r2` to the word at index `1` in the array `x` (the previous content `25` will be overwritten)

#### (3) Register Addressing (מיעון רגיסטר ישיר)

- The operand is a register. If the register is used as a destination operand, an additional data word of the command will encode in bits `2-4` the number of the register. Whereas if the register is used as a source operand, the register number will be encoded in bits `5-7` of the data word. If the command has two operands and both are direct register addressing, they will share one common data word, where bits `2-4` are for the destination register, and bits `5-7` are for the source register. A pair of bits of the field `A,R,E` are added to the data word (the value of this field is always `00` for this addressing mode). Other unused bits in the data word will contain 0s.
- The operand is a name of register.
- Example: the instruction `mov r1,r2` copies the contents of register `r1` to register `r2`. In this example, both operands are in the direct register addressing mode, so they will share one additional data word in common.

___

> Note: It is allowed to refer to the label even before it is declared, but provided that it is indeed declared somewhere in the file.

# Assembly Language

## Structure
### Macros

Reusable, symbolic names representing a sequence of instructions or other statements.

- **Macros** are pieces of code that include statements.
	- In the program you can define a macro and use it in different places in the program. The use of a macro from a certain place in the program will cause the macro to be allocated to that place. 

#### Defining & Using

In the following example the name of the macro is `m_mcr`

```
mcr m_mcr
    inc r2     
	mov  A,r1  
endmcr   
```

Using a macro is simply mentioning its name. For example, if somewhere in the program it is written:

```
.
.
.
m_mcr
.
.
m_mcr
.
.
.
```

Then the program after macro retirement will look like this.

```
.
.
.
inc r2     
mov  A,r1  
.
.
inc r2     
mov A,r1  
.
.
.
```


#### Assumptions & guidelines

- There are no nested macro definitions in the system (no need to check this).
- The name of an instruction or directive cannot be the name of a macro.
- It can be assumed that each macro line in the source code has a closure with an `endmcr` line (there is no need to check this).
- Defining a macro will always be before calling the macro (no need to check it).
- It is required that the pre-assembler create a file with the extended code that includes the macro expansion. (extension of the source file described below). The "extended source file" is a "source file" after the macro has been removed, compared to an "initial source file" which is the input file to the system, including the definition of the macros.

### Statements

- A **source file** consist of lines (max length `80`) that contains statements. (each statements is on a separate line, using `\n`)
- A **statement** is individual line or units of code in a program.


  - Statement Types
	- **Empty Statement** - This is a line that contains only whitespace characters, i.e. only the characters ` ` and `\t` (spaces and tabs). The line may not contain any characters (except for the `\n` character), which means the line is empty.
	- **Comment Statement** - This is a line in which the first character is `;` (semicolon). The assembler should completely ignore this line.
	- **Directive Statement** - instructs the assembler what to do when it runs on the source program. (There are several types of directive statements. which?? #todo  ). A directive statement may cause the allocation of memory and the initialization of program variables, but it does not produce an encoding of machine instructions intended to be executed when the program runs.
	- **Instruction Statement** - This is a statement that produces a coding of machine instructions to be executed when the program runs. The statement consists of the name of an instruction that the processor must execute, and a description of the instruction's operands.
	- **Constant Definition Statement** - This is a statement that can be used to define a symbolic name that represents a numerical constant. During the coding of the program, wherever the name appears in the code, it will be replaced by the numerical constant. This statement by itself does not generate code and does not allocate memory.

#### Directive Statement (משפטי הנחיה)

- Structure 
	- A **label** definition can appear optionally at the beginning of the statement. 
	- The **name** of the directive appears
		- A directive's name begins with the character `.` (period) followed by lower case characters only.
	- **Parameters** will appear after the name of the directive (the number of parameters according to the directive).

> **Important:** the words in the machine code that are created from the directive statement are not attached a pair of bits `A, R, E`, And the encoding fills all 14 bits of the word.

- Types #todo 
	- `.data`
	- `.string`
	- `.entry`
	- `.extern`

#### Instruction Statement (משפטי הוראה)

- **label** (optional)
	- If a label is defined on the instruction line, then it will be inserted into the **symbol table** (what is? #todo ). The value of the label will be from the *first word* of the instruction within the code image that the assembler builds.
- `opcode` of **operation-name** 
	- lower case
	- 16 operations - see [[#Machine instructions specification]]
	- separated from the first operand using space(s) or tab(s).
- **operand(s)** 
	- 0-2, depending on operation type
	- separated by `,`. (can be space(s) and tab(s) on both sides the comma)

- Structure 
	- (2 operands) `label: opcode source-operand, target-operand` (e.g. `HELLO: add r7, B`)
	- (1 operand) `label: opcode target-operand` (e.g.  `HELLO: bne XYZ`)
	- (no operand) `label: opcode` (e.g. `END: hlt`)

#### Constant Definition Statement (משפט הגדרת קבוע)

- syntax: `.define constant-name = numeric constant`
- examples: 
	- `.define len = 4`
	- `.define init = -3`
- The idea is to represent a numerical constant using a symbolic name. Anywhere in the program where the name of a constant appears, the assembler will replace the name with the numerical constant to which it was defined when encoding the command into machine code.
- The reserved word `.define` is lowercase.
- The constant must be defined before its first use. 
- You must not define a label on a line that is a *constant definition statement*.
- **constant-name**
	- The syntax of the constant name is the same as that of a label. 
	- You must not define the same constant name more than once. 
	- The same symbol cannot be used both as the name of a constant and as a label in the same program. 
	- Assembly language reserved words (name of a register, name of a machine instruction or name of a directive) cannot be used as the name of a constant. 
- The character `=` separates the name of the constant and the numerical constant. White characters are allowed on both sides of the character. 
- The **numerical constant** is an integer in decimal base. 

- The constant name can be used anywhere in the assembly program where a numerical constant can appear, (i.e. an index in the direct index addressing mode, or a value in the immediate addressing mode, or an operand of the data landing.)  :Examples, (given the constant definitions above): 
	 - `mov x[len], r3` will copy the element at index `4` in the array `x` to register `r3`.
	 - `mov #init, r2` place the immediate value `-3` into register `r2`. 
	 - `.data len` assign a word in memory with an initial value of `4`.

____

## **Specification of Fields in Assembly Statements:**


- A **label** is a symbol that is defined at the beginning of an instruction statements, or at the beginning of a `.data` or `.string` directive
	- A valid label begins with an alphabetic letter (uppercase or lowercase), followed by some series of alphabetic letters (uppercase or lowercase) and/or digits.
	- maximum length: 31 characters
	- A label definition ends with `:` (colon). This character is not part of the label, but only a mark indicating the end of the definition. The letter `:` must be adjacent to the label (without spaces).
	- The same label must not be defined more than once (of course in different lines). Uppercase and lowercase letters are treated differently.
	- Examples: `hEllo:`, `x:`, `He78902:`
	- Please note: Assembly language reserved words (that is, the name of an operation or directive, or the name of a register) cannot also be used as a label name. 
	- Also, the same symbol must not be used both as a label and as the name of a macro or constant. 
	- The label receives its value according to the context in which it is defined. A label defined in the directives `.data`, `.string`, will receive the current value of the *data counter*, while a label defined in an instruction line will receive the current value of the instruction counter (IC). (see [[#The First Pass]])
	- Attention: it is allowed in an instruction statement to use an operand that is a symbol that is not defined as a label in the current file, as long as the symbol is characterized as external (using some extern directive in the current file). 
- **Number**: valid number starts with an optional sign: `-` or `+` followed by some sequence of digits in decimal base. 
	- For example: `-5`, `76`, `+123` are valid numbers. 
	- Our assembly language does not support representation in a base other than decimal, and there is no support for non-integer numbers. 
- **String**: A valid string is a sequence of visible (printable) ASCII characters, enclosed in double quotes (the quotes are not considered part of the string). e.g. `"hello world"`.

# Assembler

- Assembler Process 
	- Construct a file containing machine code from a given file of a program written in assembly language.
		- Pre-Assembler
			- macro expansion
		- Assembler
	- Linkage. (Not part of the project)
	- Loading. (Not part of the project)

### Pre-Assembler

- When the assembler receives an assembly language program as input, it must first handle the macro expansion, and only then go over the program to which the macros were expanded. That is, the macro expansion will be done in the "pre-assembler" phase, before the assembler phase (described later). 
- If the program does not contain a macro, the retirement program will be the same as the source program.
- #todo 

#### Example

An example of a pre-assembler step. The assembler accepts the following assembly language program:

```
.define sz=2
MAIN:       mov     r3,LIST[sz]
LOOP:       jmp     L1
            mcr m_mcr
                    cmp     r3, #sz
            bne     END
            endmcr
            prn     #-5
            mov     STR[5], STR[2]
            sub     r1, r4
            m_mcr
L1:         inc     K
            bne     LOOP
END:        hlt
.define len=4
STR:        .string "abcdef"
LIST:  .data 6,-9, len    
K:          .data   22
```

First, the assembler goes through the program and expands all the macros present in it. Only if this process ends successfully, you can move on to the next step. 

In this example, the program after the macro expansion will look like this:

```
.define sz=2
MAIN:       mov     r3,LIST[sz]
LOOP:       jmp     L1
            prn     #-5
            mov     STR[5], STR[2]
            sub     r1, r4
            cmp     r3,#sz
            bne     END
L1:         inc     K
            bne     LOOP
END:        hlt
.define len=4
STR:        .string "abcdef"
LIST:  .data 6,-9, len    
K:          .data   22
```

The program code, after macro expansion, will be saved in a new file, as will be explained later.

#### Pre-Assembler Algorithm

This is a skeletal algorithm for the pre-assembler process. 

>  Note: there is no obligation to use this particular algorithm

1. Read the next line from the source file. If the file ends, go to 9 (end).
2. Is the first field a macro name appearing in the macro table (e.g. `m_mcr`)? If yes, replace the macro name and copy all corresponding lines from the table to the file, go to 1. Otherwise, continue.
3. Is the first field `mcr` (start of macro definition)? If not, go to 6.
4. Set the `mcr exists` flag.
5. (Macro definition exists) Enter the macro table with the macro name (e.g., `m_mcr`).
6. Read the next line from the source file. If the source file ends, go to 9 (end).
   If the "mcr exists" flag is on and the endmcr label is not found, insert the line into the macro table and delete the line from the file. Otherwise (not a macro), go to 1.
7. Is the `endmcr` label found? If yes, delete the label from the file and continue. If not, go to 6.
8. Turn off the `mcr exists` flag. Go to 1. (End of macro definition saving).
9. End: Save the expanded macro file.

### Two-Pass Assembler

- The **symbol table** (טבלת הסמלים) is a structure that associates symbols in the source code with a numerical value (memory address or a constant value defined by `.define`)

- the first pass 
	- the symbols (labels) that appear in the program must be identified, and each symbol must be given a numerical value which is the memory address that the symbol represents. 
- the second pass 
	- using the symbol values, as well as the opcodes and register numbers, it builds the machine code. 


- Replaceing the operations names with the corresponding opcode. 
	- In the [[#Example]]: the operations names are `mov, jmp, prn, sub, cmp, inc, bne, hlt` 
- Replaceing symbols with the names of the places in memory where each data or instruction is located respectively
	- In the example: the symbols `K,STR, LIST, LI, MAIN, LOOP, END`
- Replaceing the names of the constants defined by `.define` with the numerical constants that are the values of the corresponding constants. 
	- in the example: the constants are `len` and `sz`

  Assume that the code snippet in the above example (instructions and data) is loaded into memory starting at address 100 (in base 10). In this case we get the following "translation":
  
| Address (Decimal) | Source Code | Explanation | Binary Machine Code <br>(1-5 words of 14 bits)  |
| ---- | ---- | ---- | ---- |
| 0100<br>0101<br>0102<br>0103 | `MAIN: mov r3, LIST[sz]` | First word of instruction<br>Source register 3<br>Address of label `LIST` (integer array)<br>Value of constant `sz` (index 2) | 00000000111000<br>00000001100000<br>00001000010010<br>00000000001000 |
| 0104<br>0105 | `LOOP: jmp L1` | Address of label L1 | 00001001000100<br>00000111100010 |
| 0106<br>0107 | `prn #-5` | Immediate value -5 | 00001100000000<br>11111111101100 |
| 0108<br>0109<br>0110<br>0111<br>0112 | `mov STR[5], STR[2]` | Address of label `STR` (string)<br>Index 5<br>Address of label `STR`<br>Index 2 | 00000000101000<br>00000111110010<br>00000000010100<br>00000111110010<br>00000000001000 |
| 0113<br>0114 | `sub r1, r4` | -<br>Source register 1 and target register 4 | 00000011111100<br>00000000110000 |
| 0115<br>0116<br>0117 | `cmp r3, #sz` | -<br>Source register 3<br>Value of constant `sz` (immediate `#2`) | 00000001110000<br>00000001100000<br>00000000001000 |
| 0118<br>0119 | `bne END` | - <br>Address of label `END` | 00001010000100<br>00000111110010 |
| 0120<br>0121 | `L1: inc K` | -<br>Address of label `K` (integer) | 00000111000100<br>00001000011110 |
| 0122<br>0123 | `bne LOOP` | -<br>Address of label `LOOP` | 00001010000100<br>00000110100010 |
| 0124 | `END: hlt` |  | 00001111000000 |
| 0125 | `STR: .string "abcdef"` | ASCII code `'a'` | 00000001100001 |
| 0126 |  | ASCII code `'b'` | 00000001100010 |
| 0127 |  | ASCII code `'c'` | 00000001100011 |
| 0128 |  | ASCII code `'d'` | 00000001100100 |
| 0129 |  | ASCII code `'e'` | 00000001100101 |
| 0130 |  | ASCII code `'f'` | 00000001100110 |
| 0131 |  | ASCII code `'\0'` (end of string) | 00000000000000 |
| 0132<br>0133<br>0134 | `LIST: .data 6, -9, len` | Integer 6 (first in array of 3 words)<br>Integer -9<br>Value of constant `len` (integer 4) | 00000000000110<br>11111111110111<br>00000000000100 |
| 0135 | `K: .data 22` | Integer 22 (single word) | 00000000010110 |


- The assembler maintains a table in which all the operation names of the instructions and their corresponding binary codes are listed, so the operation names can be easily converted to binary code. 


When an operation name is called, one can simply browse the table and find the opcode. 
To perform binary conversion of operands written in addressing modes that use symbols (labels), it is necessary to build a table containing the values of all symbols.

However, unlike the opcodes, which are known in advance, the addresses in memory for the symbols used by the program are not known, until the source program has read in its entirety and all the definitions of the symbols have been discovered. 

For example, in the code above, the assembler **cannot** know that the symbol `END` is associated with `124` (decimal), and that the symbol `K` is associated with `135`, but only after all the lines of the program have been read. That is why the assembler's treatment of symbols is separated into two stages. 

- In the first step, a table of all the symbols is built, with their associated numerical values, and in the second step, all the symbols that appear in the operands of the program's instructions are replaced with their numerical values. Performing these two steps involves two scans (called "passes") of the source file. 
- In the first pass, a symbol table is built in memory. In the example above, the symbol table after the first pass is:

```
| symbol | value |
|--------|-------|
| SZ     | 2     |
| MAIN   | 100   |
| LOOP   | 104   |
| L1     | 120   |
| END    | 124   |
| len    | 4     |
| STR    | 125   |
| LIST   | 132   |
| K      | 135   |
```


- In the second pass, the source code is converted to machine code. 
	- At the beginning of the second pass, the values of the symbols should already be known.


 > [!info] Note: the role of the assembler, in its two passes, is to translate a source file into machine code.  At the end of the assembler operation, the program is not yet ready to be loaded into memory for execution. The machine code must go to the linking/loading stages, and only then to the execution stage (these stages are not part of this project). 

##### The First Pass

#todo 

- rules are required to determine which address will be associated with each symbol.
- The basic principle is to count the places in memory that the instructions occupy. If each instruction is loaded in memory to the location following the previous instruction, such a count will indicate the address of the next instruction.
- The counting is done by the assembler and held in the **instruction counter** (IC). 
- The initial value of IC is `100` (decimal), so the machine code of the first instruction is constructed so that it is loaded into memory starting at address `100`. 
- The IC is updated on each line an instruction that allocates space in memory. After the assembler determines the length of the instruction, the IC is increased by the number of cells (words) occupied by the instruction, and thus it points to the next free cell. 


- As mentioned, in order to encode the instructions in machine language, the assembler has a table, which has a corresponding opcode for each operation name. During translation, the assembler replaces each operation name with its code, and each operand is replaced with a suitable encoding, but this replacement operation is not so simple. The instructions use a variety of [[#Addressing Modes]] for operands. The same action can have different meanings, in each of the addressing modes, and therefore different codings will suit it according to the addressing mode. 
	- For example, the move operation `mov` can refer to copying the contents of a memory cell to a register, or copying the contents of a register to another register, and so on. A different encoding may be appropriate for each such option of `mov`. 


- The assembler must scan the instruction line in its entirety, and decide on the encoding according to the operands. Usually the coding is divided into the field of the name of the operation, and additional fields that contain information about the addressing modes. All the fields together require one or more words in the machine code. 
- When the assembler encounters the label that appears at the beginning of the line, it knows that it has a definition of a label in front of it, and then it associates it with Maan - the current content of the IC. This is how all the labels receive their punishments during the definition. These labels are inserted into the symbol table, which contains, in addition to the label name, the addressee and other characteristics. When there is a reference to a label in the operand of some instruction, the assembler will be able to retrieve the appropriate address from the symbol table. 



- An instruction can also refer to a symbol that has not yet been defined in the program, but will only be defined later in the program. Below is an example, a branching instruction for that is defined by the label A that appears only later in the code: `bne A ...(after some lines)... A: ...`. When the assembler reaches the branch line (`bne A`), it has not yet encountered the definition of label A and of course does not know the address associated with the label. Therefore the assembler cannot build the binary encodingof the operand A. We will see later how this problem is solved. 


In any case, it is always possible to build in the first pass the full binary encoding of the first word of each instruction, the binary encoding of the additional information word of an immediate operand, or register, as well as the binary encoding of all the data (obtained from the instructions `.string`, `.data`).

##### The Second Pass

#todo 

 We saw that in the first pass, the assembler cannot construct the machine code of operands that use symbols that have not yet been defined. Only after the assembler has gone through the entire program, so that all symbols have already entered the symbol table, can the assembler complete the machine code of all operands. For this purpose, the assembler performs an additional pass (second pass) over the entire source file, and updates the machine code of the operands that use symbols, using the symbol values from the symbol table. At the end of the second pass, the program will be completely translated into machine code.

##### Separation of instruction and data

#todo 

Separation of instructions and data In the program, two types of content are distinguished: instructions and data. The machine code must be organized so that there is separation between the data and the instructions. Separating the instructions and data into different sections of memory is a better method than attaching the data definitions to the instructions that use them. One of the dangers inherent in not separating the instructions from the data is that sometimes the processor may, following a logical error in the program, try to "execute" the data as if they were legal instructions. For example, an error that can cause such a phenomenon is incorrect branching. The program will of course not work correctly, but most of the time the damage is
Worse, because a hardware exception occurs as soon as the processor performs an illegal operation.
Our assembler must separate, in the machine code it generates, the data section from the instruction section. That is, in the output file (in the machine code) there will be a separation of instructions and data into two separate sections, while in the input file there is no obligation to have such a separation. Next, the assembler's algorithm is described, with details on how to perform the separation.

#### Errors

#todo 



#### Two-Pass Assembler Algorithm

#todo 

- First pass (18 steps)
- Second pass (10 steps)

### Input and Output Files of the Assembler


### Operation of the Assembler

### Object File Format

### Entries File Format


### Externals File Format



# Summary & General Instructions

- The length of the program, given as input to the assembler, is not known in advance, and therefore, the length of the translated program is not supposed to be predetermined. However, to facilitate the implementation of the assembler, a maximum size can be assumed. Therefore, it is possible to use arrays to store only the machine code image. Any other data structure (such as the symbol table and macro table) should be implemented efficiently and economically (for example, using a linked list and dynamic memory allocation).
- The names of the output files should match the input file name, except for the extensions. For example, if the input file is `prog.as`, then the output files created will be: `prog.ob`, `prog.ext`, `prog.ent`.
- The assembler's execution mode should be as required by the specification, without any changes. In particular, the user interface will be solely through the command line. Specifically, the names of the source files will be passed to the assembler as arguments on the command line. Interactive input menus, graphical windows, etc., should not be added.
- It is important to modularize the implementation of the assembler into several modules (C language files) according to tasks. Different tasks should not be concentrated in a single module. Recommended modules include: first pass, second pass, helper functions (such as translation to binary, syntax analysis of a line), symbol table, memory map, constant tables (operation codes, legal addressing modes for each operation, etc.).
- Care should be taken to document the implementation thoroughly and clearly, using detailed comments in the code.
- It should be possible to have extra spaces in the assembly language input file. For example, if an instruction line has two operands separated by a comma, spaces and tabs are allowed before and after the comma, as well as before and after the operation name. Empty lines are also allowed. The assembler will ignore unnecessary spaces (i.e., skip over them).
- The input (assembly code) may contain syntax errors. The assembler should detect and report all incorrect lines in the input. Processing of the input file should not stop after the first error is detected. Detailed messages should be printed to the screen whenever possible, so that it will be possible to understand what and where each error is. Of course, if the input file contains errors, there is no point in generating the output files (`ob`, `ext`, `ent`) for it.

