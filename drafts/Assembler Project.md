The Project: to write an assembler for a specific assembly language defined here specifically for this project.

## Hardware

- "The computer in the project" 
	- consists of: 
		- CPU (Central Processing Unit)
			- Registers
		- Memory (stack). Some of the memory serves as a stack (RAM).
			- size: 4096 cells
			- addresses ranging from 0 to 4095 (decimal).
			- Each cell is 14 bits in size, referred to as a "word."
			- The bits in each word are numbered similarly to the register.


- the model of the virtual computer for this project:  #todo 

- #todo 
	- This computer operates only with positive and negative integers; there is no support for floating-point numbers. Arithmetic is performed using the two's complement method.
	- There is also support for characters, represented in ascii code

# CPU

## Registers

- 8 general registers named `r0, r1, r2, r3, r4, r5, r6, r7`
- Register: 14 bits. 
	- The least significant bit denoted as bit 0 and the most significant bit as bit 13. 
	- The register names are always written with a lowercase `r`
- A register named **Program Status Word** (PSW), which contains flags characterizing the processor's state at any given moment.

## Machine Instructions

### Machine Instruction Structure

- Each machine instruction is encoded into a sequence of consecutive **memory words**, 
- range: min: one word, max: 5 words, depending on the addressing modes used (see later)
- In the output file containing the machine code generated by the assembler, each word is encoded in the Base 4 Encoded as defined below (see explanations and examples later):

| Base 4 Regular | Base 4 Encoded |
| -------------- | -------------- |
| `0`            | `*`            |
| `1`            | `#`            |
| `2`            | `%`            |
| `3`            | `!`            |

#### The first word

The structure of the first word is always the same. The structure of the first word in an instruction is as follows:

| `0 1`   | `2 3`                     | `4 5`                | `6 7 8 9` | `10 11 12 13` |
| ------- | ------------------------- | -------------------- | --------- | ------------- |
| `A, R, E` | Operand Ad. (Destination) | Operand Ad. (Source) | `opcode`    | Not used      |


- Bits `0-1` (the '`A, R, E`' field):
	- In the first word of an instruction, these bits are always set to zero (`00`).
	- The 'A, R, E' field is added to each word in the instruction encoding (see the addressing modes details). 
	- This field indicates the type of encoding for the word: **Absolute**, **External**, or **Relocatable**.
		- The value `00` means that the word is encoded **absolutely** (requiring no changes in the linkage and loading stages). 
		- The value `01` means that the encoding is for an **external address** (requiring changes in the linkage and loading stages). 
		- The value `10` means that the encoding is for a **relocatable internal address** (requiring changes in the linkage and loading stages).
- Bits `2-3`: Encode the number of the addressing mode for the **destination operand**. If there is no destination operand in the instruction, the value of these bits is 0.
- Bits `4-5`: Encode the number of the addressing mode for the **source operand**. If there is no source operand in the instruction, the value of these bits is 0.
- Bits `6-9`: In the first word of the instruction, these bits represent the **operation code** (opcode). Each opcode is symbolically represented in assembly language by an **operation name**.

| opcode | Operation Name |
| ------ | -------------- |
| 0      | mov            |
| 1      | cmp            |
| 2      | add            |
| 3      | sub            |
| 4      | not            |
| 5      | clr            |
| 6      | lea            |
| 7      | inc            |
| 8      | dec            |
| 9      | jmp            |
| 10     | bne            |
| 11     | red            |
| 12     | prn            |
| 13     | jsr            |
| 14     | rts            |
| 15     | hlt            |

- Bits `10-13`: not used and their value is `0`.

### Addressing Modes 

In our language, there are four addressing modes, marked with the numbers 0, 1, 2, and 3.

Using addressing modes requires encoding additional data words in the machine code of the instruction.

If a command has one operand, there will be one additional data word. 

If a command has two operands, there may be two additional data words, or one shared data word for both operands, depending on the addressing modes used (see specifications below).

When encoding the instruction, if there are two additional data words, the first data word refers to the source operand, and the second refers to the destination operand.

In each additional data word, bits 0-1 represent the A, R, E fields.

The following is a description of the addressing modes in our machine:


| Value | Addressing Mode                         | content of the additional information-word    |     |
| ----- | --------------------------------------- | --- | --- |
| `0`   | מיעון מיידי - Immediate Addressing      |    |     |
| `1`   | מיעון ישיר                              |     |     |
| `2`   | מיעון אינדקס קבוע                       |     |     |
| `3`   | מיעון רגיסטר ישיר - Register Addressing |     |     |


 The additional information-word of the instruction contains the operand itself, which is an integer using the 2's complement method, represented with a width of 12 bits, to which bits of the field A,R,E are added (the value of this field is always 00 for immediate addressing).

### Machine instructions specification

- **Program Counter** (PC)
	- This is an **internal register** of the processor (not a **general register**), which at any given moment contains the memory address where the current instruction being executed is located (always referring to the address of the first word of the instruction).

The machine instructions are divided into three groups, according to the number of operands required for the operation.

- The **first set** of instructions
	- number of operands: `2`
	- set: `mov, cmp, add, sub, lea`
- The **second set** of instructions:
	- number of operands: `1`
	- set: `not, clr, inc, dec, jmp, bne, red, prn, jsr`
	- The **encoding** of the operand: is the same as the target operand in a command with two operands. 
	- In this case, the field of the source operand (`4-5` bits ) In the first word in the coding of the instruction it is meaningless, and therefore will contain `00`.
- The **third set** of instructions:
	- number of operands: `0`
	- set: `rts, hlt`
	- The **encoding** of the operand: only one word
	- the field of the source & destination operands in the first word are not used, thus there are zero (???)

#### 1st set 

- The `mov` (Move) instruction is used to transfer data between registers, memory locations, and immediate values.
	- Syntax: `mov destination, source`
	- Example: `mov A, r1` copies the value from register `A` to register `r1`.
- The `cmp` (Compare) instruction performs a comparison between its two operands. the content of the destination operand (the second) is subtracted from the content of the source operand (the first), without saving the result of the subtraction. The subtraction operation updates a flag called the `Z` variable in the status register (PSW).
	- Syntax: `cmp operand1, operand2`
	- Example: `cmp A, r1`, If the contents of the variable `A` equal to the contents of register `r1` then the zero flag, `Z`, in the status register (PSW) will be turn on, otherwise the flag will be reset.
- The `add` (Addition) instruction performs integer addition between two operands and stores the result in the destination operand.
	- Syntax: `add destination, source`
	- Example: `add A, r0` adds the value in register `A` to the value in register `r0`.
- The `sub` (Subtraction) instruction performs integer subtraction between two operands and stores the result in the destination operand.
    - Syntax: `sub destination, source`
    - Example: `sub #3, r1`, register `r1` receives the result of subtracting the value `3` from the current contents of register `r1`.
- The `lea` (Load Effective Address) instruction places the address in memory represented by the label in the first operand (the source), to the destination operand (the second operand)
    - It does not access memory; it only computes the address.
    - Syntax: `lea .....???` 
    - Example: `lea HELLO, r1` The address represented by the label `HELLO` is placed in the `r1` register

#### 2nd set 

- `not` 
	- `not r2` will do `r2 ← not r2`
- `clr` 
	- `clr r2` will do `r2 ← 0`
- `inc` 
	- `inc r2` will do `r2 ← r2 + 1`
- `dec` 
	- `dec C` will do `C ← C - 1`
- `jmp` (Jump) - Unconditional jump to the instruction specified by the label.
	- Syntax `jmp LABEL`
	- Example: `jmp LINE` will do `PC ← LINE`
- `bne` (**B**ranch if **N**ot **E**qual to Zero) - Conditional branch. The program pointer (PC) will receive the value of the destination operand,  if the value of the flag `Z` in the status register (PSW) is `0`. (Reminder: The Z flag is set in the "cmp" command.)
	- Syntax `bne ....??`
	- Example `bne LINE`, if the value of the flag `Z` in the status register (PSW) is `0`, then `PC ← LINE`
- `red` (Read) - Reads a character from `stdin` (The Standard Input), and stores its ASCII code in the specified register
   - Syntax `red REGISTER`
   - Example: `red r1`
- `prn` (Print) - Prints the ASCII character represented by the operand to `stdout` (The Standard Output)
	- Syntax `prn OPERAND`
	- Example: `prn r1`
- `jsr` (Jump to Subroutine) - Calls a subroutine. The current program counter (PC) is pushed onto the stack, and the operand is inserted into PC
   - Syntax: `jsr LABEL`
   - Example: `jsr FUNC` will do `push(PC)` and then `PC ← FUNC`

#### 3rd set 

- `rts` (**R**e**T**urn from **S**ubroutine) 
	- Back from routine. The value at the top of the computer's stack is taken from the stack, and inserted into the program pointer (PC, Program Counter).
	- `rts` will do `PC ← pop()`
- `hlt` (Halt) Stopping the program

___

# Assembly Language

## Structure
### Macros

Reusable, symbolic names representing a sequence of instructions or other statements.
### Statements


- A **source file** consist of lines (max length `80`) that contains statements. (each sentence is on a separate line, using `\n`)
- A **statement** is individual line or units of code in a program.


  - Statement Types
	- **Empty Statement** - This is a line that contains only whitespace characters, i.e. only the characters ` ` and `\t` (spaces and tabs). The line may not contain any characters (except for the `\n` character), which means the line is empty.
	- **Comment Statement** - This is a line in which the first character is `;` (semicolon). The assembler should completely ignore this line.
	- **Directive Statement** - instructs the assembler what to do when it runs on the source program. (There are several types of directive sentences. which?? #todo  ). A directive statement may cause the allocation of memory and the initialization of program variables, but it does not produce an encoding of machine instructions intended to be executed when the program runs.
	- **Instruction Statement** - This is a sentence that produces a coding of machine instructions to be executed when the program runs. The statement consists of the name of an instruction that the processor must execute, and a description of the instruction's operands.
	- **Constant Definition Statement** - This is a statement that can be used to define a symbolic name that represents a numerical constant. During the coding of the program, wherever the name appears in the code, it will be replaced by the numerical constant. This statement by itself does not generate code and does not allocate memory.

#### Directive Statement (משפטי הנחיה)

##### Structure 

- A **label** definition can appear optionally at the beginning of the sentence. 
- The **name** of the directive appears
	- A directive's name begins with the character `.` (period) followed by lower case characters only.
- **Parameters** will appear after the name of the directive (the number of parameters according to the directive).

> **Important:** the words in the machine code that are created from the directive sentence are not attached a pair of bits `A, R, E`, And the encoding fills all 14 bits of the word.

##### Types 

#todo 

- `.data`
- `.string`
- `.entry`
- `.extern`

#### Instruction Statement (משפטי הוראה)

- **label** (optional)
	- If a label is defined on the instruction line, then it will be inserted into the **symbol table** (what is? #todo ). The value of the label will be from the *first word* of the instruction within the code image that the assembler builds.
- `opcode` of **operation-name** 
	- lower case
	- 16 operations - see [[Assembler Project#Machine instructions specification]]
	- separated from the first operand using space(s) or tab(s).
- **operand(s)** 
	- 0-2, depending on operation type
	- separated by `,`. (can be space(s) and tab(s) on both sides the comma)

- Structure 
	- (2 operands) `label: opcode source-operand, target-operand` (e.g. `HELLO: add r7, B`)
	- (1 operand) `label: opcode target-operand` (e.g.  `HELLO: bne XYZ`)
	- (no operand) `label: opcode` (e.g. `END: hlt`)



#### Constant Definition Statement (משפט הגדרת קבוע)

- syntax: `.define constant-name = numeric constant`
- examples: 
	- `.define len = 4`
	- `.define init = -3`
- The idea is to represent a numerical constant using a symbolic name. Anywhere in the program where the name of a constant appears, the assembler will replace the name with the numerical constant to which it was defined when encoding the command into machine code.
- The reserved word `.define` is lowercase.
- The constant must be defined before its first use. 
- You must not define a label on a line that is a *constant definition statement*.
- **constant-name**
	- The syntax of the constant name is the same as that of a label. 
	- You must not define the same constant name more than once. 
	- The same symbol cannot be used both as the name of a constant and as a label in the same program. 
	- Assembly language reserved words (name of a register, name of a machine instruction or name of a directive) cannot be used as the name of a constant. 
- The character `=` separates the name of the constant and the numerical constant. White characters are allowed on both sides of the character. 
- The **numerical constant** is an integer in decimal base. 


The constant name can be used anywhere in the assembly program where a numerical constant can appear, (i.e. an index in the direct index addressing method, or a value in the immediate addressing method, or an operand of the data landing.) 

- Examples, (given the constant definitions above): 
	 - `mov x[len], r3` will copy the element at index `4` in the array `x` to register `r3`.
	 - `mov #init, r2` place the immediate value `-3` into register `r2`. 
	 - `.data len` assign a word in memory with an initial value of `4`.

____

- **Specification of Fields in Assembly Statements:**
   - **Labels:**
     - Symbolic names assigned to memory locations or instructions for reference in the program.
   - **Definition of Labels:**
     - Explanation or assignment of symbolic labels to specific memory locations or instructions.
   - **Additional Information:**
     - Supplementary details including data, strings, data counters, instruction counters, and externals.

- Marking the Dictionary in Machine Language Using the "A,R,E" Attribute
    - a=absolute
    - r=relocatable
    - e=external

# Assembler

- Assembler 
	- Process: 
		1. Construct a file containing machine code from a given file of a program written in assembly language.
		2. Linkage. (Not part of the project)
		3. Loading. (Not part of the project)

## Pre-Assembler Algorithm

1. Read the next line from the source file. If the file ends, go to 9 (end).
2. Is the first field a macro name appearing in the macro table (e.g., `m_mcr`)? If yes, replace the macro name and copy all corresponding lines from the table to the file, go to 1. Otherwise, continue.
3. Is the first field `mcr` (start of macro definition)? If not, go to 6.
4. Set the "mcr exists" flag.
5. (Macro definition exists) Enter the macro table with the macro name (e.g., `m_mcr`).
6. Read the next line from the source file. If the source file ends, go to 9 (end).
   If the "mcr exists" flag is on and the endmcr label is not found, insert the line into the macro table and delete the line from the file. Otherwise (not a macro), go to 1.
7. Is the endmcr label found? If yes, delete the label from the file and continue. If not, go to 6.
8. Turn off the "mcr exists" flag. Go to 1. (End of macro definition saving).
9. End: Save the expanded macro file.

### Two-Pass Assembler

- An assembler that processes the source code in two passes, allowing it to resolve symbols and addresses more efficiently.

- First pass
- Second pass
- Separation of instruction and data


## Errors

## Assembler Algorithm

- First pass (18 steps)
- Second pass (10 steps)


- Input and Output Files of the Assembler
- Operation of the Assembler
- Object File Format
- Entries File Format
- Externals File Format

# Summary & General Instructions

- The length of the program, given as input to the assembler, is not known in advance, and therefore, the length of the translated program is not supposed to be predetermined. However, to facilitate the implementation of the assembler, a maximum size can be assumed. Therefore, it is possible to use arrays to store only the machine code image. Any other data structure (such as the symbol table and macro table) should be implemented efficiently and economically (for example, using a linked list and dynamic memory allocation).
- The names of the output files should match the input file name, except for the extensions. For example, if the input file is `prog.as`, then the output files created will be: `prog.ob`, `prog.ext`, `prog.ent`.
- The assembler's execution mode should be as required by the specification, without any changes. In particular, the user interface will be solely through the command line. Specifically, the names of the source files will be passed to the assembler as arguments on the command line. Interactive input menus, graphical windows, etc., should not be added.
- It is important to modularize the implementation of the assembler into several modules (C language files) according to tasks. Different tasks should not be concentrated in a single module. Recommended modules include: first pass, second pass, helper functions (such as translation to binary, syntax analysis of a line), symbol table, memory map, constant tables (operation codes, legal addressing modes for each operation, etc.).
- Care should be taken to document the implementation thoroughly and clearly, using detailed comments in the code.
- It should be possible to have extra spaces in the assembly language input file. For example, if an instruction line has two operands separated by a comma, spaces and tabs are allowed before and after the comma, as well as before and after the operation name. Empty lines are also allowed. The assembler will ignore unnecessary spaces (i.e., skip over them).
- The input (assembly code) may contain syntax errors. The assembler should detect and report all incorrect lines in the input. Processing of the input file should not stop after the first error is detected. Detailed messages should be printed to the screen whenever possible, so that it will be possible to understand what and where each error is. Of course, if the input file contains errors, there is no point in generating the output files (`ob`, `ext`, `ent`) for it.

